import pptxgen from 'pptxgenjs';
import { Slide, ContentItem } from '@/lib/types';

// Type definitions for our function parameters
interface ColorScheme {
    background: string;
    text: string;
    accent: string;
}

// Function to create a consistent heading with icon for slides
function createHeading(
    pptxSlide: pptxgen.Slide,
    slideType: string,
    slideTitle: string,
    colorScheme: ColorScheme
): void {
    let iconEmoji = "📄";
    if (slideType === 'statistics') iconEmoji = "📊";
    if (slideType === 'overview') iconEmoji = "🧭";
    if (slideType === 'detail') iconEmoji = "📄";
    if (slideType === 'comparison') iconEmoji = "⚖️";
    if (slideType === 'statistics') iconEmoji = "📈";
    if (slideType === 'case-study') iconEmoji = "🕵️‍♂️";
    if (slideType === 'conclusion') iconEmoji = "🏁";

    // Add icon and title in a row
    pptxSlide.addText(`${iconEmoji}  ${slideTitle}`, {
        x: 0.5, y: 0.4, w: '90%', h: 0.8,
        fontSize: 30,
        color: colorScheme.text,
        bold: true,
        align: 'left'
    });

    // Add a subtle divider under the title
    pptxSlide.addShape('line', {
        x: 1,
        y: 1.1,
        w: '80%',
        h: 0, // Important: makes it horizontal
        line: { color: slideType === 'conclusion' ? colorScheme.text : 'A9A9A9', width: 1 }
    });
}

// Function to convert slide data to PowerPoint
export async function exportSlidesToPptx(slides: Slide[], title: string = 'Presentation') {
    console.log(slides)
    // Create a new PowerPoint presentation
    const pptx = new pptxgen();

    // Set presentation properties
    pptx.author = 'Bionic Diamond';
    pptx.company = 'Generated by AI';
    pptx.revision = '1';
    pptx.subject = title;
    pptx.title = title;

    // Define master color schemes based on slide types
    const colorSchemes = {
        title: { background: '0062cc', text: 'ffffff', accent: 'ffffff' },
        conclusion: { background: '008f5d', text: 'ffffff', accent: 'ffffff' },
        default: { background: 'ffffff', text: '333333', accent: '0099FF' }
    };

    // Add a footer to all slides
    pptx.defineSlideMaster({
        title: 'MASTER_SLIDE',
        background: { color: 'FFFFFF' },
        objects: [
            {
                line: {
                    x: 0, y: 6.8, w: '100%', h: 0,
                    line: { color: 'DDDDDD', width: 1 }
                }
            }
        ]
    });

    // Process each slide sequentially with Promise.all to handle async operations
    await Promise.all(slides.map(async (slide, index) => {
        // Get color scheme based on slide type
        const colorScheme = slide.type === 'title' || slide.type === 'conclusion'
            ? (slide.type === 'title' ? colorSchemes.title : colorSchemes.conclusion)
            : colorSchemes.default;

        // Create a new slide using the master slide
        const pptxSlide = pptx.addSlide({ masterName: 'MASTER_SLIDE' });

        // Set background color
        pptxSlide.background = { color: colorScheme.background };

        // Title slide design
        if (slide.type === 'title') {
            // Add icon at the center top
            pptxSlide.addText("📊", {
                x: '45%',       // Center horizontally: 50% - (10% / 2)
                y: 0.8,
                w: '10%',
                h: 0.75,
                fontSize: 60,
                align: 'center',
                valign: 'middle',
            });


            // Add a decorative element (horizontal line)
            pptxSlide.addShape('line', {
                x: (10 - 1) / 2,
                y: 3,
                w: 1,            // 10% of 10in = 1in
                h: 0,
                line: { color: colorScheme.accent, width: 2 }
            });

            // Add title with larger font
            pptxSlide.addText(slide.title, {
                x: '20%',       // Center horizontally: 50% - (10% / 2)
                y: 1.8,
                w: '60%',
                h: 1.0,
                fontSize: 40,
                color: colorScheme.text,
                bold: true,
                align: 'center'
            });

            // Add subtitle if available
            const textContent = slide.content.filter(item => item.type !== 'image');
            const subtitleText = textContent.find(item => item.type === 'paragraph')?.content || '';
            if (subtitleText) {
                pptxSlide.addText(removeMarkdown(subtitleText), {
                    x: '10%',
                    y: 3.5,
                    w: '80%',
                    h: 1.0,
                    fontSize: 16,
                    color: colorScheme.text,
                    align: 'center'
                });
            }
        }

        // Slides with images
        else if (slide.content.some(item => item.type === 'image' && item.imageUrl)) {
            // Split content into text and image
            const textContent = slide.content.filter(item => item.type !== 'image');
            const imageContent = slide.content.find(item => item.type === 'image');

            // Create heading with icon
            createHeading(pptxSlide, slide.type, slide.title, colorScheme);

            // Layout for slides with images: text on left, image on right
            // Add content on the left side
            let yPos = 1.7; // Starting Y position for content

            textContent.forEach(item => {
                const content = formatContentForPptx(item);
                if (!content) return;

                // Add text with appropriate formatting
                if (item.type === 'quote') {
                    // Special formatting for quotes
                    pptxSlide.addText(content.text, {
                        x: 0.5, y: yPos, w: '45%',
                        fontSize: content.fontSize,
                        color: colorScheme.text,
                        italic: true,
                        indentLevel: 1,
                        paraSpaceBefore: 5,
                        paraSpaceAfter: 5
                    });

                    // Add a vertical line for the quote
                    pptxSlide.addShape('rect', {
                        x: 0.5, y: yPos, w: 0.1, h: content.height / 2,
                        fill: { color: colorScheme.accent },
                        line: { color: 'transparent' }
                    });
                } else if (item.type === 'list' && content.listItems) {
                    // Enhanced list formatting with better bullets - directly use the list array
                    const listItems = content.listItems || [];
                    const itemHeight = 0.3;

                    listItems.forEach((listItem, i) => {
                        // Add bullet
                        const bulletSize = 0.1;
                        const itemY = yPos + (i * itemHeight);
                        pptxSlide.addShape('ellipse', {
                            x: 0.7,
                            y: itemY,
                            w: bulletSize,
                            h: bulletSize,
                            fill: { color: colorScheme.accent }
                        });

                        // Add text
                        pptxSlide.addText(listItem, {
                            x: 0.9, y: yPos + (i * itemHeight),
                            w: '85%',
                            fontSize: content.fontSize,
                            color: colorScheme.text
                        });
                    });

                    // Update the position for the next content item
                    yPos += content.height;
                } else {
                    // Normal text formatting
                    pptxSlide.addText(content.text, {
                        x: 0.5, y: yPos, w: '45%',
                        fontSize: content.fontSize,
                        color: colorScheme.text,
                        bullet: content.bullet ? { type: 'bullet', style: '•' } : undefined,
                        italic: content.italic
                    });

                    // Update position
                    yPos += content.height;
                }
            });

            // Add image on the right side if available
            if (imageContent?.imageUrl) {
                try {
                    // Use our proxy API URL directly - pptxgen can handle URLs
                    const proxiedUrl = `/api/proxy-image?url=${encodeURIComponent(imageContent.imageUrl)}`;

                    // Create image placeholder
                    pptxSlide.addImage({
                        path: proxiedUrl,
                        x: '55%', y: 1.7, w: '40%', h: 3.5,
                        sizing: { type: 'cover', w: '40%', h: '60%' }
                    });

                } catch (error) {
                    console.error('Error adding image to slide:', error);

                    // Add a placeholder text for the failed image
                    pptxSlide.addText('[ Image could not be included ]', {
                        x: '55%', y: 3.0, w: '40%', h: 1.0,
                        fontSize: 14,
                        color: colorScheme.text,
                        italic: true,
                        align: 'center'
                    });

                    // Add a placeholder border only for failed images
                    pptxSlide.addShape('rect', {
                        x: '55%', y: 1.7, w: '40%', h: 3.5,
                        fill: { color: 'transparent' },
                        line: { color: colorScheme.accent, width: 1, dashType: 'dash' }
                    });
                }
            }
        }
        // Regular slides without images
        else {
            // Create heading with icon
            createHeading(pptxSlide, slide.type, slide.title, colorScheme);

            let yPos = 1.7; // Starting Y position

            slide.content.forEach(item => {
                const content = formatContentForPptx(item);
                if (!content) return;

                // Format differently based on content type
                if (item.type === 'quote') {
                    // Special formatting for quotes
                    pptxSlide.addText(content.text, {
                        x: 0.5, y: yPos, w: '90%',
                        fontSize: content.fontSize,
                        color: colorScheme.text,
                        italic: true,
                        indentLevel: 1,
                        paraSpaceBefore: 5,
                        paraSpaceAfter: 5
                    });

                    pptxSlide.addShape('line', {
                        x: 0.5,
                        y: yPos - 0.2,
                        w: 0,
                        h: content.height / 2,
                        line: {
                            color: colorScheme.accent,
                            width: 3
                        }
                    });

                } else if (item.type === 'list' && content.bullet) {
                    // Enhanced list formatting with better bullets - directly use the list array
                    const listItems = content.listItems || [];
                    const itemHeight = 0.3;

                    listItems.forEach((listItem, i) => {
                        // Add bullet
                        const bulletSize = 0.1;
                        const itemY = yPos + (i * itemHeight);
                        pptxSlide.addShape('ellipse', {
                            x: 0.7,
                            y: itemY,
                            w: bulletSize,
                            h: bulletSize,
                            fill: { color: colorScheme.accent }
                        });

                        // Add text
                        pptxSlide.addText(listItem, {
                            x: 0.9, y: yPos + (i * itemHeight),
                            w: '85%',
                            fontSize: content.fontSize,
                            color: colorScheme.text
                        });
                    });

                    // Update the position for the next content item
                    yPos += content.height;
                } else {
                    // Normal text formatting
                    pptxSlide.addText(content.text, {
                        x: 0.5, y: yPos, w: '90%',
                        fontSize: content.fontSize,
                        color: colorScheme.text,
                        bullet: content.bullet ? { type: 'bullet', style: '•' } : undefined,
                        italic: content.italic
                    });

                    // Update position
                    yPos += content.height;
                }
            });
        }
    }));

    // Return the PowerPoint file as a blob
    const buffer = await pptx.write({ outputType: 'blob' });
    return buffer;
}

// Helper function to format content items for PowerPoint
function formatContentForPptx(item: ContentItem): { text: string, height: number, fontSize: number, bullet: boolean, italic: boolean, listItems?: string[] } | null {
    switch (item.type) {
        case 'paragraph':
            if (!item.content) return null;
            return {
                text: removeMarkdown(item.content),
                height: 0.7, // Increased height for better spacing
                fontSize: 18, // Larger font size for better readability
                bullet: false,
                italic: false
            };

        case 'list':
            if (!item.list?.length) return null;
            // Store the original list items and process them
            const formattedList = item.list.map(listItem => removeMarkdown(listItem));
            return {
                text: formattedList.join('\n'), // Keep this for backward compatibility
                listItems: formattedList, // Store the original array
                height: 0.5 * item.list.length, // Increased height for better spacing between list items
                fontSize: 16,
                bullet: true,
                italic: false
            };

        case 'quote':
            if (!item.quote) return null;
            return {
                text: `"${removeMarkdown(item.quote)}"`,
                height: 0.8, // More space for quotes
                fontSize: 16,
                bullet: false,
                italic: true
            };

        default:
            return null;
    }
}

// Helper function to remove markdown formatting
function removeMarkdown(text: string): string {
    return text
        .replace(/\*\*(.*?)\*\*/g, '$1') // Remove bold
        .replace(/\*(.*?)\*/g, '$1')     // Remove italics
        .replace(/\[(.*?)\]\((.*?)\)/g, '$1') // Remove links
        .trim();
} 